/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(BrCompiler)
package compiler;

public class BrCompiler
{
  private static boolean parserInitialized = false;

  // mapeamento de tokens 
  private static String obterTokenPortugues(int tipoToken) {
    switch(tipoToken) {
      case INICIOPROG: return "gambiarra";
      case ABREBLOCO: return "abre-te-sesamo";
      case FECHABLOCO: return "fecha-te-sesamo";
      case INT: return "stonks";
      case FLOAT: return "fiado";
      case STRING: return "textao";
      case BOOL: return "eh-migue";
      case TRUE: return "sim";
      case FALSE: return "nao";
      case ATRIBUICAO: return "receba";
      case FIMESTRUTURA: return "br";
      case CONDICIONAL: return "sepa";
      case SENAO: return "da-teus-pulo";
      case ABRIREXP: return "[";
      case FECHAREXP: return "]";
      case ABRIRFUNC: return "(";
      case FECHARFUNC: return ")";
      case PRINT: return "printa";
      case SCAN: return "papa-entrada";
      case FOR: return "pet";
      case WHILE: return "repet";
      case FUNCAO: return "vai-filhao";
      case RETURN: return "devolva";
      case SEPARADOR: return ";";
      case SOMA: return "+";
      case SUBTRACAO: return "-";
      case MULTIPLICACAO: return "*";
      case DIVISAO: return "/";
      case OPMAIOR: return ">";
      case OPIGUAL: return "==";
      case OPMENOR: return "<";
      case OPMAIORIGUAL: return ">=";
      case OPMENORIGUAL: return "<="; 
      case OPDIF: return "!=";
      case OPAND: return "&&";
      case OPOR: return "|";
      case IDENTIFICADOR: return "identificador";
      case CONSTANTE_INT: return "numero inteiro";
      case CONSTANTE_FLOAT: return "numero decimal";
      case LITERAL_STRING: return "texto";
      case VIRGULA: return "virgula (,)";
      case LISTA: return "tropa-do-gordao";
      case ADICIONAR: return "recrutar";
      case REMOVER: return "expulsar";
      case TAMANHO: return "tamanho";
      case PILHA: return "sanduiche-iche";
      case EMPILHAR: return "montar-sanduba";
      case DESEMPILHAR: return "comer-sanduba";
      case TOPO: return "olho-gordo";
      case PILHA_VAZIA: return "farelo";
      default: return "token desconhecido";
    }
  }

  // metodo pra gerar mensagens de erro em portugues
 public static void handleParseError(ParseException e) {
    System.out.println("NOK.");
    System.out.println("ERRO DE SINTAXE:");
    
    Token currentToken = e.currentToken;
    Token tokenEncontrado = null;
    
    // tenta obter as info do token encontrado
    if (currentToken != null && currentToken.next != null) {
        tokenEncontrado = currentToken.next;  // O próximo token é o que causou o erro
    } else if (currentToken != null) {
        tokenEncontrado = currentToken;
    } else {
        // se currentToken é null, tenta pegar do token_source
        try {
            tokenEncontrado = getToken(1);  // pega o prox token
        } catch (Exception ex) {
            // se n der usa info do proprio erro
            tokenEncontrado = null;
        }
    }
    
    // aqui mostra informacoes do token que encontrou
    if (tokenEncontrado != null && tokenEncontrado.image != null) {
        System.out.println("Token encontrado: '" + tokenEncontrado.image + "' na linha " + tokenEncontrado.beginLine + ", coluna " + tokenEncontrado.beginColumn);
    } else {
        // ultima tentativa é extrair do token atual (se possivel)
        if (currentToken != null) {
            String tokenImage = currentToken.image != null ? currentToken.image : "EOF";
            int linha = currentToken.beginLine > 0 ? currentToken.beginLine : 1;
            int coluna = currentToken.beginColumn > 0 ? currentToken.beginColumn : 1;
            System.out.println("Token encontrado: '" + tokenImage + "' na linha " + linha + ", coluna " + coluna);
        } else {
            System.out.println("Token encontrado: fim de arquivo inesperado");
        }
    }
    
    // aqui mostra os tokens esperados
    if (e.expectedTokenSequences.length > 0) {
        System.out.print("Era esperado: ");
        boolean first = true;
        for (int[] sequence : e.expectedTokenSequences) {
            if (!first) System.out.print(" ou ");
            for (int i = 0; i < sequence.length; i++) {
                if (i > 0) System.out.print(" ");
                System.out.print("'" + obterTokenPortugues(sequence[i]) + "'");
            }
            first = false;
        }
        System.out.println();
    }
}

//metodo pra tratar os erros léxicos em pt br

private static void handleTokenMgrError(TokenMgrError e) {
    String msg = e.getMessage();
    
    int linha = 1;
    int coluna = 1;
    String charEncontrado = "?";
    boolean problemaNoEspaco = false;

    try {
        // extrair linha e coluna
        String[] partes = msg.split(" ");
        for (int i = 0; i < partes.length; i++) {
            if (partes[i].equals("line") && i + 1 < partes.length) {
                linha = Integer.parseInt(partes[i + 1].replace(",", ""));
            }
            if (partes[i].equals("column") && i + 1 < partes.length) {
                coluna = Integer.parseInt(partes[i + 1].replace(".", ""));
            }
        }
        
       
        if (msg.contains("after prefix")) {
            
            int start = msg.indexOf("after prefix \"") + 14;
            int end = msg.indexOf("\"", start);
            if (start > 13 && end > start) {
                String prefixo = msg.substring(start, end);
                charEncontrado = prefixo;
                
                coluna = Math.max(1, coluna - prefixo.length());
            }
        } else if (msg.contains("Encountered:") && msg.contains("(")) {
            
            int parenteseAbre = msg.lastIndexOf("(");
            int parenteseFecha = msg.indexOf(")", parenteseAbre);
            
            if (parenteseAbre != -1 && parenteseFecha != -1) {
                String codigoStr = msg.substring(parenteseAbre + 1, parenteseFecha).trim();
                
                if (codigoStr.matches("\\d+")) {
                    try {
                        int codigoAscii = Integer.parseInt(codigoStr);
                        charEncontrado = Character.toString((char) codigoAscii);
                        
                        
                        if (codigoAscii == 32 && !msg.contains("after prefix")) {
                            problemaNoEspaco = true;
                        }
                    } catch (NumberFormatException ex) {
                        charEncontrado = codigoStr;
                    }
                } else {
                    charEncontrado = codigoStr;
                }
            }
        } else {
            
            int aspasAbre = msg.indexOf("'");
            int aspasFecha = msg.indexOf("'", aspasAbre + 1);
            if (aspasAbre != -1 && aspasFecha != -1) {
                charEncontrado = msg.substring(aspasAbre + 1, aspasFecha);
            }
        }
        
       
        
    } catch (Exception ex) {
        // manter valores padrao
    }
    
    if (charEncontrado.startsWith("'") && charEncontrado.endsWith("'") && charEncontrado.length() > 1) {
        charEncontrado = charEncontrado.substring(1, charEncontrado.length() - 1);
    }

    System.out.println("NOK.");
    System.out.println("Caractere inválido '" + charEncontrado + "' encontrado na linha " + linha + ", coluna " + coluna);
    
//sugestoes pre prontas
    if (charEncontrado.equals("=")) {
        System.out.println("Sugestão: Use 'receba' para atribuição em vez de '='");
    } else if (charEncontrado.equals("@")) {
        System.out.println("Sugestão: Caractere '@' não é permitido. Use apenas caracteres válidos");
    }  else if (charEncontrado.equals("?")) {
        System.out.println("Sugestão: Ponto de interrogação não é um operador válido");
    } else if (charEncontrado.equals(":")) {
        System.out.println("Sugestão: Dois pontos não são usados na linguagem");
    } else if (charEncontrado.equals("'")) {
        System.out.println("Sugestão: Utilize aspas duplas para strings");
    } else if (charEncontrado.equals("!")) {
        System.out.println("Sugestão: Use '!=' para diferença, ou verifique a sintaxe");
    } else {
        System.out.println("Sugestão: Use apenas letras, números e os operadores definidos na linguagem");
    }
    
}



  public static int one_line() throws ParseException {
      try {
        if (!parserInitialized) {
            new BrCompiler(System.in);
            parserInitialized = true;
        } else {
            BrCompiler.ReInit(System.in);
        }
        
        BrCompiler.main();
        return 0;
      } catch (ParseException e) {
          throw e;
      }
  }

  
  public static void main(String args []) throws ParseException
{
    if (!parserInitialized) {
        new BrCompiler(System.in);
        parserInitialized = true;
    }
 
    while (true)
    {
        System.out.println("na minha maquina funciona!");
        System.out.print("comece a digitar sua gambiarra:");
        
        try
        {
            switch (BrCompiler.one_line())
            {
                case 0 : 
                System.out.println("OK.");
                break;
                case 1 : 
                System.out.println("Goodbye.");
                break;
                default : 
                break;
            }
        }
        catch (ParseException e)
        {
            handleParseError(e);
            //limpeza do buffer:  (necessaria pois alguns tokens de erro estavam sendo concatenados apos muitas interacoes no console)
            try {
                while (System.in.available() > 0) {
                    System.in.read(); // limpa caracteres restantes
                }
            } catch (Exception ex) {
                // ignora erros de limpeza
            }
            BrCompiler.ReInit(System.in);
        }
        catch (TokenMgrError e)
        {
          	handleTokenMgrError(e);
        
            //  limpeza é feita aqui tb:
            try {
                while (System.in.available() > 0) {
                    System.in.read();
                }
            } catch (Exception ex) {
                // ignora
            }
            BrCompiler.ReInit(System.in);
        }
        catch (Exception e)
        {
            System.out.println("NOK.");
            System.out.println("ERRO INESPERADO: " + e.getMessage());
            BrCompiler.ReInit(System.in);
        }
        catch (Error e)
        {
            System.out.println("Oops.");
            System.out.println("ERRO FATAL: " + e.getMessage());
            break;
        }
    }
}//main

} //compilador


PARSER_END(BrCompiler)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /*funcoes e estru. dados */
{
  <PRINT: "printa" >			|
  <SCAN: "papa-entrada" >		|
  <FOR: "pet" >					|
  <WHILE: "repet" >				|	
  <SEPARADOR: ";" >				|
  <FUNCAO: "vai-filhao" >		|
  <RETURN: "devolva">			|
  <VIRGULA: ",">				
  
}

TOKEN : /*estrururas de dados*/
{
  <LISTA: "tropa-do-gordao" >		| //"membros da tropa" / informa o tamanho da lista. precisa ser complementado com um print
  <ADICIONAR: "recrutar" >  		|
  <REMOVER: "expulsar" >  			|  
  <TAMANHO: "tamanho" >				| 
  <PILHA: "sanduiche-iche" >    	|
  <EMPILHAR: "montar-sanduba">		|
  <DESEMPILHAR: "comer-sanduba">  	|
  <TOPO: "olho-gordo">				|
  <PILHA_VAZIA: "farelo">
}

TOKEN : /*estruturas*/
{
  <INICIOPROG: "gambiarra">															|
  <ABREBLOCO: "abre-te-sesamo">														|	
  <FECHABLOCO: "fecha-te-sesamo">													|
  <INT: "stonks">																	|
  <FLOAT: "fiado">																	|
  <STRING: "textao">																|
  <BOOL: "eh-migue">																|
  <TRUE: "sim">																		|
  <FALSE: "nao">																	|
  <ATRIBUICAO: "receba">															|
  <FIMESTRUTURA: "br">																|
  <CONDICIONAL: "sepa">																|
  <SENAO: "da-teus-pulo">															|
  <ABRIREXP: "[">																	|
  <FECHAREXP: "]">																	|
  <ABRIRFUNC: "(">																	|
  <FECHARFUNC: ")">																	|
  <LITERAL_STRING:"\"" (~["\""])* "\"">												|
  <CONSTANTE_INT: (<DIGITO>)+>														|
  <CONSTANTE_FLOAT: (<DIGITO>)+ "." (<DIGITO>)+>									|
  <IDENTIFICADOR: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z"] | "-" | "_"| <DIGITO>)*>	|
  <#DIGITO : [ "0"-"9" ]> 
}

TOKEN: /*operacoes*/
{
 <SOMA : "+">											|	
 <SUBTRACAO : "-">										|
 <MULTIPLICACAO : "*">									|
 <DIVISAO : "/">										|
 <OPMAIOR: ">">											|
 <OPIGUAL: "==">										|
 <OPMENOR: "<">											|
 <OPDIF: "!=">											|
 <OPMAIORIGUAL: " >=" >									|
 <OPMENORIGUAL: "<=" >									|
 <OPAND: "&&" >											|
 <OPOR: "|" >								
}


void main() :
{}
{
  <INICIOPROG> <ABREBLOCO> bloco() <FECHABLOCO> 
}

void bloco():
{}
{
 	(comando() | declaraFuncao())*
}

void comando():
{ }
{
   declaraVariavel() 					|
   expressaoCondicional()             	|
   LOOKAHEAD(3) comandoFuncao()         |
   LOOKAHEAD(3) operacaoLista()         |
   LOOKAHEAD(3) operacaoPilha()			|
   LOOKAHEAD(2) atribuicao()			|   //resolve conflito de indecibilidade entre atribuicao e expressao
   Expressao() <FIMESTRUTURA>	 		|
   print()								|
   scan()								|
   whileLoop()							|
   forLoop()							|
   retorno()
    
}

void declaraVariavel():
{ }
{
	tipoDado()
	ListaIdentificadores()
	(
	  	<ATRIBUICAO> ListaExpressoes()
	)?
	<FIMESTRUTURA>
}

void tipoDado():
{ }
{
  (<INT> | <FLOAT>| <STRING> | <BOOL> | tipoLista() | tipoPilha())

}

void atribuicao():
{ }
{
  <IDENTIFICADOR> <ATRIBUICAO> Expressao() <FIMESTRUTURA>
}

void ListaIdentificadores(): //permite varias declaracoes de variaveis
{ }
{
  <IDENTIFICADOR> (<VIRGULA> <IDENTIFICADOR>)*
}

void ListaExpressoes():
{}
{
  Expressao()
  (
    <VIRGULA> Expressao()
  )*
}


void Expressao():
{ }
{
  fator()
  (
    (<SOMA> | <SUBTRACAO>)
    fator()
  )*
}

void fator(): { } //fazer respeitar hierarquia de operacoes
{
   termo()
  (
    (<MULTIPLICACAO> | <DIVISAO>)
    termo()
  )*
}

void termo(): 
{}
{
  LOOKAHEAD( <IDENTIFICADOR> <ABRIRFUNC> ) chamadaFuncao()						|
  <IDENTIFICADOR> (<ABRIREXP> (ListaExpressoes())? <FECHAREXP>)?				| 
  <CONSTANTE_INT>																|
  <CONSTANTE_FLOAT>																|
  <LITERAL_STRING>																|
  <TRUE>																		|
  <FALSE>																		|
  <TAMANHO> <IDENTIFICADOR>                                      				|  
  inicializacaoLista()                                            				|
  <TOPO> <IDENTIFICADOR>														|
  <PILHA_VAZIA> <IDENTIFICADOR>													|
  "(" Expressao() ")" 			//reconhecer prioridade de parentese
}									   

void operadorLogico():
{ }
{
  (<OPDIF> | <OPIGUAL> | <OPMAIOR> | <OPMENOR> | <OPMAIORIGUAL> | <OPMENORIGUAL> | <OPAND> | <OPOR>)
}

void expressaoLogica():
{ }
{
  Expressao() operadorLogico() Expressao()
}

void expressaoCondicional():
{}
{
  condicao() (<SENAO> (
    					condicao() |
  						<ABREBLOCO> bloco() <FECHABLOCO>)
  					  )?
}

void condicao():
{ }
{
  <CONDICIONAL> <ABRIREXP> expressaoLogica() <FECHAREXP> <ABREBLOCO> bloco() <FECHABLOCO>
}

void print():
{ }
{
   	<PRINT> ListaExpressoes() <FIMESTRUTURA>  
}

void scan():
{}
{
   <SCAN> <IDENTIFICADOR> <FIMESTRUTURA>
}

void whileLoop():
{}
{
  	<WHILE> <ABRIREXP > expressaoLogica() <FECHAREXP>
  			 <ABREBLOCO> bloco() <FECHABLOCO>
}

void forLoop():
{}
{
  <FOR> <ABRIREXP>
  			atribuicaoFor() <SEPARADOR>
  			expressaoLogica() <SEPARADOR>
  			atribuicaoFor()

  		 <FECHAREXP>
  		 <ABREBLOCO>
			bloco()
  		 <FECHABLOCO>
}

void atribuicaoFor():
{}
{
  (tipoDado())? <IDENTIFICADOR> <ATRIBUICAO> Expressao()
}

//tratar escopo na analise semantica
void declaraFuncao():  //tipoDado é opcional para permitir funções sem retorno, sem precisar adicionar o tipo void
{}
{
 <FUNCAO> (tipoDado())? <IDENTIFICADOR> <ABRIRFUNC> (listaParametros())? <FECHARFUNC>
 						  <ABREBLOCO> bloco() <FECHABLOCO>

//ex: funcao int numeroPrimo [int a, int b ] { comandos }
}

void listaParametros():
{}
{
  parametro() (<VIRGULA> parametro())*
}

void parametro():
{}
{
  tipoDado() <IDENTIFICADOR>
}

void retorno():
{}
{
	<RETURN> (Expressao())?<FIMESTRUTURA>
}

void chamadaFuncao(): //usa em expressoes, que exigem que a funcao retorne tipo
{}
{
  <IDENTIFICADOR> <ABRIRFUNC> (ListaExpressoes())? <FECHARFUNC>
  // ex: somar(5, 10), usada em expressões
}

// é para chamar funções void criadas pelo usuário. Usada em comandos independentes. Não dá pra usar em expressões
void comandoFuncao():
{}
{
  
  <IDENTIFICADOR> <ABRIRFUNC> (ListaExpressoes())? <FECHARFUNC> <FIMESTRUTURA>
  // ex: imprime("oi");  função void como comando
}

void tipoLista():
{ }
{
  <LISTA> (<INT> | <FLOAT> | <STRING> | <BOOL>) //nao chamei tipoDado pra nao criar recursao infinita de lista int lista int lista int lista 
}

void inicializacaoLista():
{}
{
  <ABRIREXP> (ListaExpressoes())? <FECHAREXP> // ex: [1, 2, 3]
}

void operacaoLista():
{}
{
  LOOKAHEAD(2) <IDENTIFICADOR> <ADICIONAR> Expressao() <FIMESTRUTURA> 			|
  <IDENTIFICADOR> <REMOVER> <ABRIREXP> Expressao() <FECHAREXP> <FIMESTRUTURA>
}

void tipoPilha():
{}
{
  <PILHA> (<INT> | <FLOAT> | <STRING> | <BOOL>)
}

void operacaoPilha():
{}
{
  LOOKAHEAD(2) <IDENTIFICADOR> <EMPILHAR> Expressao() <FIMESTRUTURA>     |  
  <IDENTIFICADOR> <DESEMPILHAR> <FIMESTRUTURA>								//desempilhar precisa da parte semantica
}


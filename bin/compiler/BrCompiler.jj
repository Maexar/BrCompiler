/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 * GRAMÁTICA REFATORADA PARA LL(1) - Eliminação de LOOKAHEADs e Ambiguidades
 */
options
{
  static = true;
}

PARSER_BEGIN(BrCompiler)
package compiler;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.StringReader;

public class BrCompiler
{
  
  private static boolean parserInitialized = false;

  // mapeamento de tokens 
  private static String obterTokenPortugues(int tipoToken) {
    switch(tipoToken) {
      case INICIOPROG: return "gambiarra";
      case ABREBLOCO: return "abre-te-sesamo";
      case FECHABLOCO: return "fecha-te-sesamo";
      case INT: return "stonks";
      case FLOAT: return "fiado";
      case STRING: return "textao";
      case BOOL: return "eh-migue";
      case TRUE: return "sim";
      case FALSE: return "nao";
      case ATRIBUICAO: return "receba";
      case FIMESTRUTURA: return "br";
      case CONDICIONAL: return "sepa";
      case SENAO: return "da-teus-pulo";
      case ABRIREXP: return "[";
      case FECHAREXP: return "]";
      case ABRIRFUNC: return "(";
      case FECHARFUNC: return ")";
      case PRINT: return "printa";
      case SCAN: return "papa-entrada";
      case FOR: return "pet";
      case WHILE: return "repet";
      case FUNCAO: return "vai-filhao";
      case RETURN: return "devolva";
      case SEPARADOR: return ";";
      case SOMA: return "+";
      case SUBTRACAO: return "-";
      case MULTIPLICACAO: return "*";
      case DIVISAO: return "/";
      case OPMAIOR: return ">";
      case OPIGUAL: return "==";
      case OPMENOR: return "<";
      case OPMAIORIGUAL: return ">=";
      case OPMENORIGUAL: return "<="; 
      case OPDIF: return "!=";
      case OPAND: return "&&";
      case OPOR: return "|";
      case IDENTIFICADOR: return "identificador";
      case CONSTANTE_INT: return "numero inteiro";
      case CONSTANTE_FLOAT: return "numero decimal";
      case LITERAL_STRING: return "texto";
      case VIRGULA: return "virgula (,)";
      case LISTA: return "tropa-do-gordao";
      case ADICIONAR: return "recrutar";
      case REMOVER: return "expulsar";
      case TAMANHO: return "tamanho";
      case PILHA: return "sanduiche-iche";
      case EMPILHAR: return "montar-sanduba";
      case DESEMPILHAR: return "comer-sanduba";
      case TOPO: return "olho-gordo";
      case PILHA_VAZIA: return "farelo";
      default: return "token desconhecido";
    }
  }

//conta cada delimitador de bloco aberto
private static int verificarBlocos(String input) {
    int nivel = 0;
    String[] tokens = input.split("\\s+");
    
    for (String token : tokens) {
        if (token.equals("abre-te-sesamo")) {
            nivel++;
        } else if (token.equals("fecha-te-sesamo")) {
            nivel--;
            if (nivel < 0) {
                return -1; // erro: fechamento sem abertura
            }
        }
    }
    return nivel; // 0 = balanceado, >0 = blocos não fechados
}

// metodo pra tratar erros e gerar mensagens de erro em portugues
public static void handleParseError(ParseException e) {
    // Detecção melhorada para bloco não fechado
    boolean blocoNaoFechado = false;
    
    if (e.currentToken != null) {
        // Caso 1: Token atual é EOF - chegamos ao fim sem fechar o bloco
        if (e.currentToken.kind == EOF) {
            blocoNaoFechado = true;
        }
        // Caso 2: Próximo token é EOF - estamos no último token antes do fim
        else if (e.currentToken.next != null && e.currentToken.next.kind == EOF) {
            blocoNaoFechado = true;
        }
        // Caso 3: Verifica se estava esperando FECHABLOCO mas não encontrou
        else if (e.expectedTokenSequences != null) {
            for (int[] sequence : e.expectedTokenSequences) {
                for (int tokenType : sequence) {
                    if (tokenType == FECHABLOCO) {
                        blocoNaoFechado = true;
                        break;
                    }
                }
                if (blocoNaoFechado) break;
            }
        }
    }
    
    if (blocoNaoFechado) {
        System.out.println("NOK.");
        System.out.println("ERRO DE SINTAXE: Bloco não fechado");
        System.out.println("Faltou adicionar 'fecha-te-sesamo' para fechar bloco de comando");
        
        // Tenta dar uma posição mais específica
        if (e.currentToken != null) {
            System.out.println("Erro detectado próximo à linha " + e.currentToken.beginLine + 
                             ", coluna " + e.currentToken.beginColumn);
        }
        return;
    }
    
    // Resto do método para outros tipos de erro
    System.out.println("NOK.");
    System.out.println("ERRO DE SINTAXE:");
    
    Token currentToken = e.currentToken;
    Token tokenEncontrado = null;
    
    // tenta obter as info do token encontrado
    if (currentToken != null && currentToken.next != null) {
        tokenEncontrado = currentToken.next;
    } else if (currentToken != null) {
        tokenEncontrado = currentToken;
    } else {
        try {
            tokenEncontrado = getToken(1);
        } catch (Exception ex) {
            tokenEncontrado = null;
        }
    }
    
    // aqui mostra informacoes do token que encontrou
    if (tokenEncontrado != null && tokenEncontrado.image != null) {
        System.out.println("Token encontrado: '" + tokenEncontrado.image + "' na linha " + 
                         tokenEncontrado.beginLine + ", coluna " + tokenEncontrado.beginColumn);
    } else {
        if (currentToken != null) {
            String tokenImage = currentToken.image != null ? currentToken.image : "EOF";
            int linha = currentToken.beginLine > 0 ? currentToken.beginLine : 1;
            int coluna = currentToken.beginColumn > 0 ? currentToken.beginColumn : 1;
            System.out.println("Token encontrado: '" + tokenImage + "' na linha " + linha + ", coluna " + coluna);
        } else {
            System.out.println("Token encontrado: fim de arquivo inesperado");
        }
    }
    
    // aqui mostra os tokens esperados
    if (e.expectedTokenSequences.length > 0) {
        System.out.print("Era esperado: ");
        boolean first = true;
        for (int[] sequence : e.expectedTokenSequences) {
            if (!first) System.out.print(" ou ");
            for (int i = 0; i < sequence.length; i++) {
                if (i > 0) System.out.print(" ");
                System.out.print("'" + obterTokenPortugues(sequence[i]) + "'");
            }
            first = false;
        }
        System.out.println();
    }
}

//metodo pra tratar os erros léxicos em pt br

private static void handleTokenMgrError(TokenMgrError e) {
    String msg = e.getMessage();
    
    int linha = 1;
    int coluna = 1;
    String charEncontrado = "?";
    boolean problemaNoEspaco = false;

    try {
        // extrair linha e coluna
        String[] partes = msg.split(" ");
        for (int i = 0; i < partes.length; i++) {
            if (partes[i].equals("line") && i + 1 < partes.length) {
                linha = Integer.parseInt(partes[i + 1].replace(",", ""));
            }
            if (partes[i].equals("column") && i + 1 < partes.length) {
                coluna = Integer.parseInt(partes[i + 1].replace(".", ""));
            }
        }
        
       
        if (msg.contains("after prefix")) {
            
            int start = msg.indexOf("after prefix \"") + 14;
            int end = msg.indexOf("\"", start);
            if (start > 13 && end > start) {
                String prefixo = msg.substring(start, end);
                charEncontrado = prefixo;
                
                coluna = Math.max(1, coluna - prefixo.length());
            }
        } else if (msg.contains("Encountered:") && msg.contains("(")) {
            
            int parenteseAbre = msg.lastIndexOf("(");
            int parenteseFecha = msg.indexOf(")", parenteseAbre);
            
            if (parenteseAbre != -1 && parenteseFecha != -1) {
                String codigoStr = msg.substring(parenteseAbre + 1, parenteseFecha).trim();
                
                if (codigoStr.matches("\\d+")) {
                    try {
                        int codigoAscii = Integer.parseInt(codigoStr);
                        charEncontrado = Character.toString((char) codigoAscii);
                        
                        
                        if (codigoAscii == 32 && !msg.contains("after prefix")) {
                            problemaNoEspaco = true;
                        }
                    } catch (NumberFormatException ex) {
                        charEncontrado = codigoStr;
                    }
                } else {
                    charEncontrado = codigoStr;
                }
            }
        } else {
            
            int aspasAbre = msg.indexOf("'");
            int aspasFecha = msg.indexOf("'", aspasAbre + 1);
            if (aspasAbre != -1 && aspasFecha != -1) {
                charEncontrado = msg.substring(aspasAbre + 1, aspasFecha);
            }
        }
        
       
        
    } catch (Exception ex) {
        // manter valores padrao
    }
    
    if (charEncontrado.startsWith("'") && charEncontrado.endsWith("'") && charEncontrado.length() > 1) {
        charEncontrado = charEncontrado.substring(1, charEncontrado.length() - 1);
    }

    System.out.println("NOK.");
    System.out.println("ERRO LÉXICO");
    System.out.println("Caractere inválido '" + charEncontrado + "' encontrado na linha " + linha + ", coluna " + coluna);
    
//sugestoes pre prontas
    if (charEncontrado.equals("=")) {
        System.out.println("Sugestão: Use 'receba' para atribuição em vez de '='");
    } else if (charEncontrado.equals("@")) {
        System.out.println("Sugestão: Caractere '@' não é permitido. Use apenas caracteres válidos");
    }  else if (charEncontrado.equals("?")) {
        System.out.println("Sugestão: Ponto de interrogação não é um operador válido");
    } else if (charEncontrado.equals(":")) {
        System.out.println("Sugestão: Dois pontos não são usados na linguagem");
    } else if (charEncontrado.equals("'")) {
        System.out.println("Sugestão: Utilize aspas duplas para strings");
    } else if (charEncontrado.equals("!")) {
        System.out.println("Sugestão: Use '!=' para diferença, ou verifique a sintaxe");
    } else {
        System.out.println("Sugestão: Use apenas letras, números e os operadores definidos na linguagem");
    }
    
}

public static int one_line() throws ParseException {
    try {
        if (!parserInitialized) {
            new BrCompiler(System.in);
            parserInitialized = true;
        } else {
            BrCompiler.ReInit(System.in);
        }
        
        BrCompiler.main();
        return 0;
    } catch (ParseException e) {
        // verifica se o erro é devido a EOF (entrada incompleta)
        if (e.currentToken != null && e.currentToken.kind == EOF) {
            System.out.println("NOK.");
            System.out.println("ERRO DE SINTAXE: Entrada incompleta");
            System.out.println("Verifique se todos os blocos foram fechados com 'fecha-te-sesamo'");
            return -1; // codigo especial pra entrada incompleta
        }
        throw e;
    }
}

  
 public static void main(String args[]) throws ParseException {
    if (!parserInitialized) {
        new BrCompiler(System.in);
        parserInitialized = true;
    }

    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    
    while (true) {
        System.out.println("na minha maquina funciona!");
        System.out.print("comece a digitar sua gambiarra:");

        try {
            String line = reader.readLine();
            
            // trata EOF (Ctrl+Z) corretamente
            if (line == null) {
                System.out.println("\nSaindo...");
                break;
            }
            
            line = line.trim();
            
            if (line.isEmpty()) {
                continue; // so continua se a linha estiver vazia
            }
            
            
            
            BrCompiler.ReInit(new StringReader(line));
            BrCompiler.main();
            System.out.println("OK.");
            
        } catch (ParseException e) {
            handleParseError(e);
        } catch (TokenMgrError e) {
            handleTokenMgrError(e);
        } catch (Exception e) {
            System.out.println("NOK.");
            System.out.println("ERRO INESPERADO: " + e.getMessage());
            
            // Se for erro de stream fechada (EOF), sai do programa
            if (e.toString().contains("Stream closed") || e.toString().contains("null")) {
                System.out.println("Saindo...");
                break;
            }
        }
    }
}

} //compilador


PARSER_END(BrCompiler)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"

}

TOKEN : /*funcoes */
{
  <PRINT: "printa" >			|
  <SCAN: "papa-entrada" >		|
  <FOR: "pet" >				|
  <WHILE: "repet" >			|	
  <SEPARADOR: ";" >			|
  <FUNCAO: "vai-filhao" >		|
  <RETURN: "devolva">			|
  <VIRGULA: ",">			
  
}

TOKEN : /*estrururas de dados*/
{
  <LISTA: "tropa-do-gordao" >		| 
  <ADICIONAR: "recrutar" >  		|
  <REMOVER: "expulsar" >  		|  
  <TAMANHO: "tamanho" >			| //\"membros da tropa\" / informa o tamanho da lista. precisa ser complementado com um print
  <PILHA: "sanduiche-iche" >    	|
  <EMPILHAR: "montar-sanduba">		|
  <DESEMPILHAR: "comer-sanduba">  	|
  <TOPO: "olho-gordo">			|
  <PILHA_VAZIA: "farelo">
}

TOKEN : /*estruturas*/
{
  <INICIOPROG: "gambiarra">						|
  <ABREBLOCO: "abre-te-sesamo">					|	
  <FECHABLOCO: "fecha-te-sesamo">				|
  <INT: "stonks">								|
  <FLOAT: "fiado">								|
  <STRING: "textao">							|
  <BOOL: "eh-migue">							|
  <TRUE: "sim">									|
  <FALSE: "nao">								|
  <ATRIBUICAO: "receba">						|
  <FIMESTRUTURA: "br">							|
  <CONDICIONAL: "sepa">							|
  <SENAO: "da-teus-pulo">						|
  <ABRIREXP: "[">								|
  <FECHAREXP: "]">								|
  <ABRIRFUNC: "(">								|
  <FECHARFUNC: ")">								|
  <LITERAL_STRING:"\"" (~["\""])* "\"">			|
  <CONSTANTE_INT: (<DIGITO>)+>					|
  <CONSTANTE_FLOAT: (<DIGITO>)+ "." (<DIGITO>)+>	|
  <IDENTIFICADOR: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z"] | "-" | "_"| <DIGITO>)*>	|
  <#DIGITO : [ "0"-"9" ]> 
}

TOKEN: /*operacoes*/
{
 <SOMA : "+">							|	
 <SUBTRACAO : "-">						|
 <MULTIPLICACAO : "*">					|
 <DIVISAO : "/">						|
 <OPMAIOR: ">">							|
 <OPIGUAL: "==">						|
 <OPMENOR: "<">							|
 <OPDIF: "!=">							|
 <OPMAIORIGUAL: " >=" >					|
 <OPMENORIGUAL: "<=" >					|
 <OPAND: "&&" >							|
 <OPOR: "|" >							
}


/* =====================================================
   REGRAS GRAMATICAIS REFATORADAS PARA LL(1)
   Eliminação de LOOKAHEADs através de Fatoração
   ===================================================== */

void main() :
{}
{
  <INICIOPROG> <ABREBLOCO> bloco() <FECHABLOCO> 
}

void bloco():
{}
{
 	(comando() | declaraFuncao())*
}

/* ========== COMANDO REFATORADO (SEM LOOKAHEADs) ========== */
void comando():
{ }
{
   declaraVariavel() 			|
   expressaoCondicional()       |
   comandoIdentificador()       |
   print()					|
   scan()					|
   whileLoop()				|
   forLoop()				|
   retorno()
}

/* ===== NOVO: FATORAÇÃO PARA COMANDOS COM IDENTIFICADOR ===== */
/*
 * Esta produção resolve a ambiguidade eliminando os LOOKAHEADs
 * ao fatora todos os comandos que começam com IDENTIFICADOR
 */
void comandoIdentificador():
{}
{
  <IDENTIFICADOR> comandoIdentificadorSufixo()
}

void comandoIdentificadorSufixo():
{}
{
  <ATRIBUICAO> Expressao() <FIMESTRUTURA>                                    |
  <ABRIRFUNC> (ListaExpressoes())? <FECHARFUNC> <FIMESTRUTURA>               |
  <ADICIONAR> Expressao() <FIMESTRUTURA>                                     |
  <REMOVER> <ABRIREXP> Expressao() <FECHAREXP> <FIMESTRUTURA>                |
  <EMPILHAR> Expressao() <FIMESTRUTURA>                                      |
  <DESEMPILHAR> <FIMESTRUTURA>                                               |
  (<ABRIREXP> (ListaExpressoes())? <FECHAREXP>)? sufixoExpressao()
}

void sufixoExpressao():
{}
{
  ((<SOMA> | <SUBTRACAO>) fator())* <FIMESTRUTURA>
}

/* ===================================================== */

void declaraVariavel():
{ }
{
	tipoDado()
	ListaIdentificadores()
	(
	  	<ATRIBUICAO> ListaExpressoes()
	)?
	<FIMESTRUTURA>
}

void tipoDado():
{ }
{
  (<INT> | <FLOAT>| <STRING> | <BOOL> | tipoLista() | tipoPilha())

}

void ListaIdentificadores():
{ }
{
  <IDENTIFICADOR> (<VIRGULA> <IDENTIFICADOR>)*
}

void ListaExpressoes():
{}
{
  Expressao()
  (
    <VIRGULA> Expressao()
  )*
}

void Expressao():
{ }
{
  fator()
  (
    (<SOMA> | <SUBTRACAO>)
    fator()
  )*
}

void fator(): { }
{
   termo()
  (
    (<MULTIPLICACAO> | <DIVISAO>)
    termo()
  )*
}

/* ========== TERMO REFATORADO (SEM LOOKAHEAD) ========== */
void termo(): 
{}
{
  <IDENTIFICADOR> termoIdentificadorSufixo()                    |
  <CONSTANTE_INT>                                               |
  <CONSTANTE_FLOAT>                                             |
  <LITERAL_STRING>                                              |
  <TRUE>                                                        |
  <FALSE>                                                       |
  <TAMANHO> <IDENTIFICADOR>                                     |  
  inicializacaoLista()                                          |
  <TOPO> <IDENTIFICADOR>                                        |
  <PILHA_VAZIA> <IDENTIFICADOR>                                 |
  "(" Expressao() ")"
}

/*
 * Esta produção resolve a ambiguidade entre chamada de função
 * e acesso a variável/array ao utilizar 1 token lookahead
 */
void termoIdentificadorSufixo():
{}
{
  <ABRIRFUNC> (ListaExpressoes())? <FECHARFUNC>               |
  (<ABRIREXP> (ListaExpressoes())? <FECHAREXP>)?
}

/* ===================================================== */

void operadorLogico():
{ }
{
  (<OPDIF> | <OPIGUAL> | <OPMAIOR> | <OPMENOR> | <OPMAIORIGUAL> | <OPMENORIGUAL> | <OPAND> | <OPOR>)
}

void expressaoLogica():
{ }
{
  Expressao() operadorLogico() Expressao()
}

void expressaoCondicional():
{}
{
  condicao() (<SENAO> (
    	condicao() |
  	<ABREBLOCO> bloco() <FECHABLOCO>)
  	)?
}

void condicao():
{ }
{
  <CONDICIONAL> <ABRIREXP> expressaoLogica() <FECHAREXP> <ABREBLOCO> bloco() <FECHABLOCO>
}

void print():
{ }
{
   	<PRINT> ListaExpressoes() <FIMESTRUTURA>  
}

void scan():
{}
{
   <SCAN> <IDENTIFICADOR> <FIMESTRUTURA>
}

void whileLoop():
{}
{
  	<WHILE> <ABRIREXP > expressaoLogica() <FECHAREXP>
  		 <ABREBLOCO> bloco() <FECHABLOCO>
}

void forLoop():
{}
{
  <FOR> <ABRIREXP>
  		atribuicaoFor() <SEPARADOR>
  		expressaoLogica() <SEPARADOR>
  		atribuicaoFor()
  		 <FECHAREXP>
  		 <ABREBLOCO>
			bloco()
  		 <FECHABLOCO>
}

void atribuicaoFor():
{}
{
  (tipoDado())? <IDENTIFICADOR> <ATRIBUICAO> Expressao()
}

void declaraFuncao():
{}
{
 <FUNCAO> (tipoDado())? <IDENTIFICADOR> <ABRIRFUNC> (listaParametros())? <FECHARFUNC>
 	<ABREBLOCO> bloco() <FECHABLOCO>
}

void listaParametros():
{}
{
  parametro() (<VIRGULA> parametro())*
}

void parametro():
{}
{
  tipoDado() <IDENTIFICADOR>
}

void retorno():
{}
{
	<RETURN> (Expressao())?<FIMESTRUTURA>
}

void tipoLista():
{ }
{
  <LISTA> (<INT> | <FLOAT> | <STRING> | <BOOL>)
}

void inicializacaoLista():
{}
{
  <ABRIREXP> (ListaExpressoes())? <FECHAREXP>
}

void tipoPilha():
{}
{
  <PILHA> (<INT> | <FLOAT> | <STRING> | <BOOL>)
}
